"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mcaddonTask = exports.zipTask = void 0;
const node_core_library_1 = require("@rushstack/node-core-library");
const path_1 = __importDefault(require("path"));
const zip_lib_1 = require("zip-lib");
const just_scripts_1 = require("just-scripts");
function addContentsToZip(zipContents, zip) {
    for (const content of zipContents) {
        for (const originPath of content.contents) {
            const inputPath = path_1.default.resolve(originPath);
            const pathStats = node_core_library_1.FileSystem.getLinkStatistics(inputPath);
            if (pathStats.isDirectory()) {
                console.log(`Adding folder ${inputPath} to package`);
                zip.addFolder(inputPath, content.targetPath);
            }
            else {
                const metadataPath = content.targetPath
                    ? path_1.default.join(content.targetPath, path_1.default.parse(inputPath).base)
                    : undefined;
                console.log(`Adding file ${inputPath} to package`);
                zip.addFile(inputPath, metadataPath);
            }
        }
    }
}
/**
 * A just task which compresses files into a specified output file.
 */
function zipTask(outputFile, zipContents) {
    return async function zip() {
        if (zipContents.length === 0 || !zipContents.some(content => content.contents.length > 0)) {
            process.exitCode = 0;
            return Promise.resolve();
        }
        const zip = new zip_lib_1.Zip();
        addContentsToZip(zipContents, zip);
        let isSucceeded = true;
        let errorMessage = '';
        await zip.archive(outputFile).then(function () {
            console.error(`Compressed file created at ${outputFile}`);
        }, function (err) {
            isSucceeded = false;
            errorMessage = `Compressed file failed to be created at ${outputFile}: ${err}`;
            console.error(errorMessage);
        });
        if (isSucceeded) {
            process.exitCode = 0;
            return Promise.resolve();
        }
        process.exitCode = 1;
        return Promise.reject(new Error(errorMessage));
    };
}
exports.zipTask = zipTask;
/**
 * A just task which creates the mcaddon file.
 */
function mcaddonTask(params) {
    const targetFolder = path_1.default.parse(params.outputFile).dir;
    const outputFileName = path_1.default.parse(params.outputFile).name;
    const behaviorPackFile = path_1.default.join(targetFolder, `${outputFileName}_bp.mcpack`);
    const resourcePackFile = path_1.default.join(targetFolder, `${outputFileName}_rp.mcpack`);
    const mcaddonContents = { contents: [behaviorPackFile] };
    if (params.copyToResourcePacks && params.copyToResourcePacks.length > 0) {
        mcaddonContents.contents.push(resourcePackFile);
    }
    (0, just_scripts_1.task)('packBP', zipTask(behaviorPackFile, [
        { contents: params.copyToBehaviorPacks },
        { contents: params.copyToScripts, targetPath: 'scripts' },
    ]));
    (0, just_scripts_1.task)('packRP', zipTask(resourcePackFile, [{ contents: params.copyToResourcePacks ?? [] }]));
    (0, just_scripts_1.task)('packMcaddon', zipTask(params.outputFile, [mcaddonContents]));
    return (0, just_scripts_1.series)((0, just_scripts_1.parallel)('packBP', 'packRP'), 'packMcaddon');
}
exports.mcaddonTask = mcaddonTask;
//# sourceMappingURL=zip.js.map