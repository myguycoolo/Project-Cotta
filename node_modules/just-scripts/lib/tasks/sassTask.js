"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sassTask = void 0;
const glob = require("glob");
const path = require("path");
const fs = require("fs");
const just_task_1 = require("just-task");
const tryRequire_1 = require("../tryRequire");
const parallelLimit = require("run-parallel-limit");
function sassTask(optionsOrCreateSourceModule, postcssPlugins) {
    let createSourceModule;
    if (typeof optionsOrCreateSourceModule === 'function') {
        createSourceModule = optionsOrCreateSourceModule;
    }
    else {
        createSourceModule = optionsOrCreateSourceModule.createSourceModule;
        postcssPlugins = optionsOrCreateSourceModule.postcssPlugins;
    }
    postcssPlugins = postcssPlugins || [];
    return function sass(done) {
        const sass = tryRequire_1.tryRequire('sass') || tryRequire_1.tryRequire('node-sass');
        const postcss = tryRequire_1.tryRequire('postcss');
        const autoprefixer = tryRequire_1.tryRequire('autoprefixer');
        const postcssRtl = tryRequire_1.tryRequire('postcss-rtl');
        const clean = tryRequire_1.tryRequire('postcss-clean');
        if (!sass || !postcss || !autoprefixer) {
            just_task_1.logger.warn('One or more dependencies (sass or node-sass, postcss, autoprefixer) is not installed, so this task has no effect');
            done();
            return;
        }
        const autoprefixerFn = autoprefixer({ overrideBrowserslist: ['> 1%', 'last 2 versions', 'ie >= 11'] });
        const files = glob.sync(path.resolve(process.cwd(), 'src/**/*.scss'));
        if (files.length) {
            const tasks = files.map((fileName) => function (cb) {
                fileName = path.resolve(fileName);
                sass.render({
                    file: fileName,
                    importer: patchSassUrl,
                    includePaths: [path.resolve(process.cwd(), 'node_modules')],
                }, (err, result) => {
                    if (err) {
                        cb(path.relative(process.cwd(), fileName) + ': ' + err);
                    }
                    else {
                        const css = result.css.toString();
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        const plugins = [autoprefixerFn, ...postcssPlugins];
                        // If the rtl plugin exists, insert it after autoprefix.
                        if (postcssRtl) {
                            plugins.splice(plugins.indexOf(autoprefixerFn) + 1, 0, postcssRtl({}));
                        }
                        // If postcss-clean exists, add it to the end of the chain.
                        if (clean) {
                            plugins.push(clean());
                        }
                        postcss(plugins)
                            .process(css, { from: fileName })
                            .then((result) => {
                            fs.writeFileSync(fileName + '.ts', createSourceModule(fileName, result.css));
                            cb();
                        });
                    }
                });
            });
            parallelLimit(tasks, 5, done);
        }
        else {
            done();
        }
    };
}
exports.sassTask = sassTask;
function requireResolvePackageUrl(packageUrl) {
    const fullName = packageUrl + (packageUrl.endsWith('.scss') ? '' : '.scss');
    return just_task_1.resolveCwd(fullName) || just_task_1.resolveCwd(path.join(path.dirname(fullName), `_${path.basename(fullName)}`));
}
function patchSassUrl(url, _prev, _done) {
    let newUrl = url;
    if (url[0] === '~') {
        newUrl = requireResolvePackageUrl(url.substr(1)) || '';
    }
    else if (url === 'stdin') {
        newUrl = '';
    }
    return { file: newUrl };
}
//# sourceMappingURL=sassTask.js.map