"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.copyTask = void 0;
const glob = require("glob");
const fse = require("fs-extra");
const path = require("path");
const just_task_1 = require("just-task");
const parallelLimit = require("run-parallel-limit");
function copyTask(optionsOrPaths, dest, limit) {
    let paths = [];
    if (Array.isArray(optionsOrPaths)) {
        paths = optionsOrPaths;
    }
    else if (optionsOrPaths) {
        paths = optionsOrPaths.paths || [];
        dest = optionsOrPaths.dest;
        limit = optionsOrPaths.limit;
    }
    limit = limit || 15;
    return function copy(done) {
        just_task_1.logger.info(`Copying [${paths.map(p => path.relative(process.cwd(), p)).join(', ')}] to '${dest}'`);
        if (!fse.existsSync(dest)) {
            fse.mkdirpSync(dest);
        }
        const copyTasks = [];
        function helper(srcPath, basePath = '') {
            basePath = basePath || getBasePath(srcPath);
            const matches = glob.sync(srcPath);
            matches.forEach(matchedPath => {
                if (fse.existsSync(matchedPath)) {
                    const stat = fse.statSync(matchedPath);
                    if (stat.isDirectory()) {
                        return helper(path.join(matchedPath, '**/*'), basePath);
                    }
                }
                const relativePath = path.relative(basePath, matchedPath);
                copyTasks.push(cb => {
                    const readStream = fse.createReadStream(matchedPath);
                    const destPath = path.join(dest, relativePath);
                    if (!fse.existsSync(path.dirname(destPath))) {
                        fse.mkdirpSync(path.dirname(destPath));
                    }
                    readStream.pipe(fse.createWriteStream(destPath));
                    readStream.on('error', err => cb(err));
                    readStream.on('end', cb);
                });
            });
        }
        paths.forEach(copyPath => helper(copyPath));
        parallelLimit(copyTasks, limit, done);
    };
}
exports.copyTask = copyTask;
/* eslint-enable @typescript-eslint/no-non-null-assertion */
function getBasePath(pattern) {
    const parts = path.resolve(pattern).split(/[\/\\]/g);
    const relativePathParts = [];
    for (let i = 0; i < parts.length; i++) {
        if (parts[i].startsWith('*')) {
            break;
        }
        relativePathParts.push(parts[i]);
    }
    const relativePath = relativePathParts.join(path.sep);
    if (fse.existsSync(relativePath)) {
        const stat = fse.statSync(relativePath);
        if (!stat.isDirectory()) {
            return path.dirname(relativePath);
        }
    }
    return relativePath;
}
//# sourceMappingURL=copyTask.js.map