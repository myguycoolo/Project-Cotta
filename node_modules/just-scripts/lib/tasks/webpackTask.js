"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.webpackTask = void 0;
const just_task_1 = require("just-task");
const tryRequire_1 = require("../tryRequire");
const fs = require("fs");
const path = require("path");
const webpack_merge_1 = require("webpack-merge");
const findWebpackConfig_1 = require("../webpack/findWebpackConfig");
const enableTypeScript_1 = require("just-task/lib/enableTypeScript");
function webpackTask(options) {
    return async function webpack() {
        const wp = tryRequire_1.tryRequire('webpack');
        if (!wp) {
            just_task_1.logger.warn('webpack is not installed, this task no effect');
            return;
        }
        just_task_1.logger.info(`Running Webpack`);
        const webpackConfigPath = options && options.config ? just_task_1.resolveCwd(path.join('.', options.config)) : findWebpackConfig_1.findWebpackConfig('webpack.config.js');
        just_task_1.logger.info(`Webpack Config Path: ${webpackConfigPath}`);
        if (webpackConfigPath && fs.existsSync(webpackConfigPath) && webpackConfigPath.endsWith('.ts')) {
            const transpileOnly = options ? options.transpileOnly !== false : true;
            enableTypeScript_1.enableTypeScript({ transpileOnly });
        }
        const configLoader = webpackConfigPath ? require(path.resolve(webpackConfigPath)) : {};
        let webpackConfigs;
        // If the loaded webpack config is a function
        // call it with the original process.argv arguments from build.js.
        if (typeof configLoader == 'function') {
            webpackConfigs = configLoader(just_task_1.argv().env, just_task_1.argv());
        }
        else {
            webpackConfigs = configLoader;
        }
        if (!Array.isArray(webpackConfigs)) {
            webpackConfigs = [webpackConfigs];
        }
        // Convert everything to promises first to make sure we resolve all promises
        const webpackConfigPromises = await Promise.all(webpackConfigs.map(webpackConfig => Promise.resolve(webpackConfig)));
        // We support passing in arbitrary webpack config options that we need to merge with any read configs.
        // To do this, we need to filter out the properties that aren't valid config options and then run webpack merge.
        // A better long term solution here would be to have an option called webpackConfigOverrides instead of extending the configuration object.
        const { config, outputStats, onCompile, ...restConfig } = options || {};
        webpackConfigs = webpackConfigPromises.map(webpackConfig => webpack_merge_1.merge(webpackConfig, restConfig));
        return new Promise((resolve, reject) => {
            wp(webpackConfigs, async (err, stats) => {
                if (options && options.onCompile) {
                    const results = options.onCompile(err, stats);
                    if (typeof results === 'object' && results.then) {
                        await results;
                    }
                }
                if (options && options.outputStats) {
                    const statsFile = options.outputStats === true ? 'stats.json' : options.outputStats;
                    fs.writeFileSync(statsFile, JSON.stringify(stats.toJson(), null, 2));
                }
                if (err || stats.hasErrors()) {
                    // Stats may be undefined the the case of an error in Webpack 5
                    if (stats) {
                        just_task_1.logger.error(stats.toString({ children: webpackConfigs.map(c => c.stats) }));
                        reject(`Webpack failed with ${stats.toJson('errors-only').errors.length} error(s).`);
                    }
                    else {
                        just_task_1.logger.error(err.toString());
                        reject(`Webpack failed with error(s).`);
                    }
                }
                else {
                    resolve();
                }
            });
        });
    };
}
exports.webpackTask = webpackTask;
//# sourceMappingURL=webpackTask.js.map