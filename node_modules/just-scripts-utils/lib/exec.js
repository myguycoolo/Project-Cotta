"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.spawn = exports.execSync = exports.encodeArgs = exports.exec = void 0;
const cp = require("child_process");
const path_1 = require("path");
const SEPARATOR = process.platform === 'win32' ? ';' : ':';
/**
 * Execute a command.
 *
 * @param cmd Command to execute
 * @param opts Normal exec options plus stdout/stderr for piping output. Can pass `process` for this param.
 * @returns Promise which will settle when the command completes. If output was not piped, it will be
 * returned as the promise's value. If the promise was rejected, the error will be of type `ExecError`.
 */
function exec(cmd, opts = {}) {
    return new Promise((resolve, reject) => {
        var _a, _b;
        const child = cp.exec(cmd, opts, (error, stdout, stderr) => {
            if (error) {
                error.stdout = stdout;
                error.stderr = stderr;
                reject(error);
            }
            else {
                resolve(stdout);
            }
        });
        if (opts.stdout) {
            (_a = child.stdout) === null || _a === void 0 ? void 0 : _a.pipe(opts.stdout);
        }
        if (opts.stderr) {
            (_b = child.stderr) === null || _b === void 0 ? void 0 : _b.pipe(opts.stderr);
        }
    });
}
exports.exec = exec;
/**
 * Encode args for a shell command.
 * @param cmdArgs Args to encode
 * @returns Encoded args
 */
function encodeArgs(cmdArgs) {
    // Taken from https://github.com/xxorax/node-shell-escape/blob/master/shell-escape.js
    // However, we needed to use double quotes because that's the norm in more platforms
    if (!cmdArgs) {
        return cmdArgs;
    }
    return cmdArgs.map(arg => {
        if (/[^\w/:=-]/.test(arg)) {
            arg = `"${arg.replace(/"/g, '"\\"')}"`;
            arg = arg.replace(/^(?:"")+/g, '').replace(/\\"""/g, '\\"');
        }
        return arg;
    });
}
exports.encodeArgs = encodeArgs;
/**
 * Execute a command synchronously.
 *
 * @param cmd  Command to execute
 * @param cwd Working directory in which to run the command (default: `process.cwd()`)
 * @param returnOutput If true, return the command's output. If false/unspecified,
 * inherit stdio from the parent process (so the child's output goes to the console).
 * @returns If `returnOutput` is true, returns the command's output. Otherwise returns undefined.
 */
function execSync(cmd, cwd, returnOutput) {
    cwd = cwd || process.cwd();
    const env = { ...process.env };
    env.PATH = path_1.resolve('./node_modules/.bin') + SEPARATOR + env.PATH;
    const output = cp.execSync(cmd, {
        cwd,
        env,
        stdio: returnOutput ? undefined : 'inherit',
    });
    return returnOutput ? (output || '').toString('utf8') : undefined;
}
exports.execSync = execSync;
/**
 * Execute a command in a new process.
 *
 * @param cmd Command to execute
 * @param args Args for the command
 * @param opts Normal spawn options plus stdout/stderr for piping output. Can pass `process` for this param.
 * @returns Promise which will settle when the command completes. If the promise is rejected, the error will
 * include the child process's exit code.
 */
function spawn(cmd, args = [], opts = {}) {
    return new Promise((resolve, reject) => {
        var _a, _b;
        const child = cp.spawn(cmd, args, opts);
        child.on('exit', (code, signal) => {
            if (code) {
                const error = new Error('Command failed: ' + [cmd, ...args].join(' '));
                error.code = code;
                reject(error);
            }
            else if (signal) {
                const error = new Error(`Command terminated by signal ${signal}: ` + [cmd, ...args].join(' '));
                error.signal = signal;
                reject(error);
            }
            else {
                resolve();
            }
        });
        if (opts.stdout) {
            (_a = child.stdout) === null || _a === void 0 ? void 0 : _a.pipe(opts.stdout);
        }
        if (opts.stderr) {
            (_b = child.stderr) === null || _b === void 0 ? void 0 : _b.pipe(opts.stderr);
        }
    });
}
exports.spawn = spawn;
