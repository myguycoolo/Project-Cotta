/// <reference types="node" />
import * as cp from 'child_process';
export interface ExecError extends cp.ExecException {
    stdout?: string;
    stderr?: string;
}
/**
 * Execute a command.
 *
 * @param cmd Command to execute
 * @param opts Normal exec options plus stdout/stderr for piping output. Can pass `process` for this param.
 * @returns Promise which will settle when the command completes. If output was not piped, it will be
 * returned as the promise's value. If the promise was rejected, the error will be of type `ExecError`.
 */
export declare function exec(cmd: string, opts?: cp.ExecOptions & {
    stdout?: NodeJS.WritableStream;
    stderr?: NodeJS.WritableStream;
}): Promise<string | undefined>;
/**
 * Encode args for a shell command.
 * @param cmdArgs Args to encode
 * @returns Encoded args
 */
export declare function encodeArgs(cmdArgs: string[]): string[];
/**
 * Execute a command synchronously.
 *
 * @param cmd  Command to execute
 * @param cwd Working directory in which to run the command (default: `process.cwd()`)
 * @param returnOutput If true, return the command's output. If false/unspecified,
 * inherit stdio from the parent process (so the child's output goes to the console).
 * @returns If `returnOutput` is true, returns the command's output. Otherwise returns undefined.
 */
export declare function execSync(cmd: string, cwd?: string, returnOutput?: boolean): string | undefined;
/**
 * Execute a command in a new process.
 *
 * @param cmd Command to execute
 * @param args Args for the command
 * @param opts Normal spawn options plus stdout/stderr for piping output. Can pass `process` for this param.
 * @returns Promise which will settle when the command completes. If the promise is rejected, the error will
 * include the child process's exit code.
 */
export declare function spawn(cmd: string, args?: ReadonlyArray<string>, opts?: cp.SpawnOptions & {
    stdout?: NodeJS.WritableStream;
    stderr?: NodeJS.WritableStream;
}): Promise<void>;
//# sourceMappingURL=exec.d.ts.map