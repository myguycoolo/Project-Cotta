"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.undertaker = exports.series = exports.parallel = void 0;
const logger_1 = require("./logger");
const chalk = require("chalk");
const wrapTask_1 = require("./wrapTask");
const cache_1 = require("./cache");
const Undertaker = require("undertaker");
const undertaker = new Undertaker();
exports.undertaker = undertaker;
const NS_PER_SEC = 1e9;
let topLevelTask = undefined;
let errorReported = false;
const tasksInProgress = {};
const colors = [chalk.cyanBright, chalk.magentaBright, chalk.blueBright, chalk.greenBright, chalk.yellowBright];
const taskColor = {};
let colorIndex = 0;
function shouldLog(taskArgs) {
    return (!taskArgs.branch &&
        taskArgs.name !== '<anonymous>' &&
        !taskArgs.name.endsWith('?') &&
        taskArgs.name !== '_wrapFunction' &&
        taskArgs.name !== 'default');
}
function colorizeTaskName(taskName) {
    if (taskColor[taskName] === undefined) {
        taskColor[taskName] = colorIndex;
        colorIndex = (colorIndex + 1) % colors.length;
    }
    return colors[taskColor[taskName]](taskName);
}
undertaker.on('start', function (args) {
    if (shouldLog(args)) {
        if (!topLevelTask) {
            topLevelTask = args.name;
        }
        tasksInProgress[args.name] = true;
        logger_1.logger.info(`started '${colorizeTaskName(args.name)}'`);
    }
});
undertaker.on('stop', function (args) {
    if (shouldLog(args)) {
        const duration = args.duration;
        const durationInSecs = Math.round(((duration[0] * NS_PER_SEC + duration[1]) / NS_PER_SEC) * 100) / 100;
        delete tasksInProgress[args.name];
        logger_1.logger.info(`finished '${colorizeTaskName(args.name)}' in ${chalk.yellow(String(durationInSecs) + 's')}`);
    }
});
undertaker.on('error', function (args) {
    delete tasksInProgress[args.name];
    if (!errorReported) {
        errorReported = true;
        logger_1.logger.error(chalk.red(`Error detected while running '${colorizeTaskName(args.name)}'`));
        logger_1.logger.error(chalk.yellow('------------------------------------'));
        const stackOrMessage = args.error.stack || args.error.message || args.error;
        if (stackOrMessage) {
            logger_1.logger.error(chalk.yellow(stackOrMessage));
        }
        if (args.error.stdout) {
            logger_1.logger.error(chalk.yellow('stdout:'));
            logger_1.logger.error(args.error.stdout);
        }
        if (args.error.stderr) {
            logger_1.logger.error(chalk.yellow('stderr:'));
            logger_1.logger.error(args.error.stderr);
        }
        logger_1.logger.error(chalk.yellow('------------------------------------'));
        cache_1.clearCache();
        process.exitCode = 1;
    }
    else if (shouldLog(args)) {
        const duration = args.duration;
        const durationInSecs = Math.round(((duration[0] * NS_PER_SEC + duration[1]) / NS_PER_SEC) * 100) / 100;
        logger_1.logger.error(`finished '${colorizeTaskName(args.name)}' in ${chalk.yellow(String(durationInSecs) + 's')} with ${chalk.red('errors')}`);
        process.exitCode = 1;
    }
    if (topLevelTask === args.name) {
        process.exit(1);
    }
});
process.on('exit', code => {
    if (code !== 0) {
        logger_1.logger.error(chalk.dim(`Error previously detected. See above for error messages.`));
    }
    if (Object.keys(tasksInProgress).length > 0) {
        logger_1.logger.error(`Other tasks that did not complete: [${Object.keys(tasksInProgress)
            .map(taskName => colorizeTaskName(taskName))
            .join(', ')}]`);
    }
});
function parallel(...tasks) {
    const newTasks = tasks.map(task => {
        if (typeof task === 'string') {
            return task;
        }
        else {
            return wrapTask_1.wrapTask(task);
        }
    });
    return undertaker.parallel(newTasks);
}
exports.parallel = parallel;
function series(...tasks) {
    const newTasks = tasks.map(task => {
        if (typeof task === 'string') {
            return task;
        }
        else {
            return wrapTask_1.wrapTask(task);
        }
    });
    return undertaker.series(newTasks);
}
exports.series = series;
undertaker.series.bind(undertaker);
