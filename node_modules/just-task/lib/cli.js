"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const undertaker_1 = require("./undertaker");
const option_1 = require("./option");
const just_task_logger_1 = require("just-task-logger");
const config_1 = require("./config");
const task_1 = require("./task");
const originalEmitWarning = process.emitWarning;
process.emitWarning = function emitWarning(_warning, _type, code, 
// eslint-disable-next-line @typescript-eslint/ban-types
_ctor) {
    if (code === 'DEP0097') {
        // Undertaker uses a deprecated approach that causes NodeJS 10 to print
        // this warning to stderr:
        //
        // "Using a domain property in MakeCallback is deprecated. Use the  async_context
        // variant of MakeCallback or the AsyncResource class instead."
        // Suppress the warning!
        return;
    }
    return originalEmitWarning.apply(this, arguments);
};
function showHelp() {
    const tasks = undertaker_1.undertaker.registry().tasks();
    console.log('All the tasks that are available to just:');
    for (const [name, wrappedTask] of Object.entries(tasks)) {
        const unwrapped = wrappedTask.unwrap ? wrappedTask.unwrap() : wrappedTask;
        const description = unwrapped.description;
        console.log(`  ${name}${description ? `: ${description}` : ''}`);
    }
}
// Define a built-in option of "config" so users can specify which path to choose for configurations
option_1.option('config', {
    describe: 'path to a just configuration file (includes the file name, e.g. /path/to/just.config.ts)',
});
option_1.option('defaultConfig', {
    describe: 'path to a default just configuration file that will be used when the current project does not have a just configuration file. (includes the file name, e.g. /path/to/just.config.ts)',
});
option_1.option('esm', {
    describe: 'Configure ts-node to support imports of ESM package (changes TS module/moduleResolution settings to Node16)',
});
const registry = undertaker_1.undertaker.registry();
const configModule = config_1.readConfig();
// Support named task function as exports of a config module
if (configModule && typeof configModule === 'object') {
    for (const taskName of Object.keys(configModule)) {
        if (typeof configModule[taskName] == 'function') {
            task_1.task(taskName, configModule[taskName]);
        }
    }
}
const command = option_1.parseCommand();
if (command) {
    if (registry.get(command)) {
        undertaker_1.undertaker.series(registry.get(command))(() => undefined);
    }
    else {
        just_task_logger_1.logger.error(`Command not defined: ${command}`);
        process.exitCode = 1;
    }
}
else {
    showHelp();
}
