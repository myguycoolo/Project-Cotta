"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveCwd = exports.resolve = exports._getResolvePaths = exports._tryResolve = exports._isFileNameLike = exports.resetResolvePaths = exports.addResolvePath = void 0;
const resolve_1 = require("resolve");
const path = require("path");
const option_1 = require("./option");
let customResolvePaths = [];
/**
 * Add a path to the list used by `resolve()`.
 * @param pathName Path to add
 */
function addResolvePath(pathName) {
    customResolvePaths.push(pathName);
}
exports.addResolvePath = addResolvePath;
/**
 * Reset the list of paths used by `resolve()`.
 */
function resetResolvePaths() {
    customResolvePaths = [];
}
exports.resetResolvePaths = resetResolvePaths;
/**
 * Exported for testing only.
 * @private
 */
function _isFileNameLike(name) {
    return !!name && name.includes('.') && !name.includes('/') && !name.includes('\\');
}
exports._isFileNameLike = _isFileNameLike;
/**
 * Exported for testing only.
 * @private
 */
function _tryResolve(moduleName, options) {
    try {
        const { cwd, ...rest } = options;
        const nameToResolve = _isFileNameLike(moduleName) ? `./${moduleName}` : moduleName;
        return resolve_1.sync(nameToResolve, { basedir: cwd, ...rest, preserveSymlinks: true });
    }
    catch (e) {
        return null;
    }
}
exports._tryResolve = _tryResolve;
/**
 * Exported for testing only.
 * @private
 */
function _getResolvePaths(cwd) {
    if (!cwd) {
        cwd = process.cwd();
    }
    const configArg = option_1.argv().config;
    const configFilePath = configArg ? path.resolve(path.dirname(configArg)) : undefined;
    return [cwd, ...(configFilePath ? [configFilePath] : []), ...customResolvePaths, __dirname];
}
exports._getResolvePaths = _getResolvePaths;
function resolve(moduleName, cwdOrOptions) {
    let options = {};
    if (typeof cwdOrOptions === 'string') {
        options = { cwd: cwdOrOptions };
    }
    else if (cwdOrOptions) {
        options = cwdOrOptions;
    }
    const allResolvePaths = _getResolvePaths(options.cwd);
    let resolved = null;
    for (const tryPath of allResolvePaths) {
        resolved = _tryResolve(moduleName, { ...options, cwd: tryPath });
        if (resolved) {
            return resolved;
        }
    }
    return null;
}
exports.resolve = resolve;
function resolveCwd(moduleName, cwdOrOptions) {
    let options = {};
    if (typeof cwdOrOptions === 'string') {
        options = { cwd: cwdOrOptions };
    }
    else if (cwdOrOptions) {
        options = cwdOrOptions;
    }
    if (!options.cwd) {
        options.cwd = process.cwd();
    }
    return _tryResolve(moduleName, options);
}
exports.resolveCwd = resolveCwd;
